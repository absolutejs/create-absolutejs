import { mkdirSync, writeFileSync } from 'fs';
import { join } from 'path';
import type { AvailableDependency, CreateConfiguration } from '../../types';
import type { FrameworkFlags } from './computeFlags';

type GenerateImportsBlockProps = {
	backendDirectory: string;
	deps: AvailableDependency[];
	flags: FrameworkFlags;
	orm: CreateConfiguration['orm'];
	authProvider: CreateConfiguration['authProvider'];
	databaseEngine: CreateConfiguration['databaseEngine'];
	databaseHost: CreateConfiguration['databaseHost'];
};

export const generateImportsBlock = ({
	backendDirectory,
	deps,
	flags,
	orm,
	authProvider,
	databaseEngine,
	databaseHost
}: GenerateImportsBlockProps) => {
	const rawImports: string[] = [];

	const pushHandler = (condition: boolean, name: string) =>
		condition &&
		rawImports.push(`import { ${name} } from '@absolutejs/absolute';`);

	pushHandler(flags.requiresHtml, 'handleHTMLPageRequest');
	pushHandler(flags.requiresReact, 'handleReactPageRequest');
	pushHandler(flags.requiresSvelte, 'handleSveltePageRequest');
	pushHandler(flags.requiresVue, 'handleVuePageRequest');
	pushHandler(flags.requiresVue, 'generateHeadElement');
	pushHandler(flags.requiresHtmx, 'handleHTMXPageRequest');

	const nonFrameworkOnly =
		(flags.requiresHtml || flags.requiresHtmx) &&
		!flags.requiresReact &&
		!flags.requiresSvelte &&
		!flags.requiresVue;

	deps.forEach((dependency) => {
		const importsList = dependency.imports ?? [];
		const filteredList = nonFrameworkOnly
			? importsList.filter(
					(modImport) => modImport.packageName !== 'asset'
				)
			: importsList;
		if (filteredList.length) {
			rawImports.push(
				`import { ${filteredList
					.map((modImport) => modImport.packageName)
					.sort()
					.join(', ')} } from '${dependency.value}';`
			);
		}
	});

	if (flags.requiresReact) {
		rawImports.push(
			`import { ReactExample } from '../frontend/react/pages/ReactExample';`
		);
	}
	if (flags.requiresSvelte) {
		rawImports.push(
			`import SvelteExample from '../frontend/svelte/pages/SvelteExample.svelte';`
		);
	}
	if (flags.requiresVue && !flags.requiresSvelte) {
		rawImports.push(
			`import VueExample from '../frontend/vue/pages/VueExample.vue';`
		);
	}

	const drizzleHostImports = {
		neon: [
			`import { neon } from '@neondatabase/serverless';`,
			`import { drizzle } from 'drizzle-orm/neon-http';`
		],
		planetscale: [
			`import { connect } from '@planetscale/database';`,
			`import { drizzle } from 'drizzle-orm/planetscale-serverless';`
		],
		turso: [
			`import { createClient } from '@libsql/client';`,
			`import { drizzle } from 'drizzle-orm/libsql';`
		]
	} as const;

	if (orm === 'drizzle') {
		const hostImports =
			databaseHost === 'neon' ||
			databaseHost === 'planetscale' ||
			databaseHost === 'turso'
				? drizzleHostImports[databaseHost]
				: [];

		rawImports.push(
			`import { Elysia } from 'elysia';`,
			`import { getEnv } from '@absolutejs/absolute';`,
			`import { schema } from '../../db/schema';`,
			...hostImports
		);
	}

	if (
		authProvider === 'absoluteAuth' &&
		databaseEngine !== undefined &&
		databaseEngine !== 'none'
	) {
		rawImports.push(
			`import { instantiateUserSession } from '@absolutejs/auth';`
		);
	}

	if (flags.requiresVue && flags.requiresSvelte) {
		const utilsDir = join(backendDirectory, 'utils');
		mkdirSync(utilsDir, { recursive: true });
		writeFileSync(
			join(utilsDir, 'vueImporter.ts'),
			`// Auto-generated by AbsoluteJS to wrap Vue imports.
// Prevents the Vue language server from over checking Svelte imports
// and taking over where Svelte's language server should operate.
import VueExample from "../../frontend/vue/pages/VueExample.vue";

export const vueImports = { VueExample } as const;
`
		);
		rawImports.push(`import { vueImports } from './utils/vueImporter';`);
	}

	const importMap = new Map<
		string,
		{ defaultImport: string | null; namedImports: Set<string> }
	>();

	rawImports.forEach((statement) => {
		const matchResult = statement.match(
			/^import\s+(.+)\s+from\s+['"](.+)['"];/
		);
		if (!matchResult) return;
		const [, importClause, modulePath] = matchResult;
		if (!importClause || !modulePath) return;
		const entry = importMap.get(modulePath) ?? {
			defaultImport: null,
			namedImports: new Set<string>()
		};
		importMap.set(modulePath, entry);
		if (importClause.startsWith('{')) {
			importClause
				.slice(1, -1)
				.split(',')
				.map((fragment) => fragment.trim())
				.filter(Boolean)
				.forEach((name) => entry.namedImports.add(name));
		} else {
			entry.defaultImport = importClause.trim();
		}
	});

	return Array.from(importMap.entries())
		.sort(([pathA], [pathB]) => pathA.localeCompare(pathB))
		.map(([modulePath, { defaultImport, namedImports }]) => {
			const parts: string[] = [];
			if (defaultImport) parts.push(defaultImport);
			if (namedImports.size)
				parts.push(`{ ${[...namedImports].sort().join(', ')} }`);

			return `import ${parts.join(', ')} from '${modulePath}';`;
		})
		.join('\n');
};
